# tom hensel <github@jitter.eu> 2016
# powered by https://github.com/zimbatm/direnv
# -*- mode: bash; coding:utf-8; tab-width: 2; indent-tabs-mode: nil; -*-

set -e

### layout
layout_virtualenv() {
  local venv_path="$1"
  check_string "$venv_path" || return 1

  unalias pydoc 2>/dev/null
  pydoc () {
    python -m pydoc "$@"
  }
  if test -z "${PYTHONHOME+_}"; then
    unset PYTHONHOME
  fi
  export VIRTUAL_ENV
  VIRTUAL_ENV="$venv_path"
  PATH_add "$VIRTUAL_ENV/bin"

  local python_rc_file="$HOME/.python/pythonrc.py"
  if test -f "$python_rc_file"; then
    export PYTHONSTARTUP
    PYTHONSTARTUP="$python_rc_file"
  fi
  export PYTHON_HISTORY_FILE
  PYTHON_HISTORY_FILE="$HOME/.python_history"
  if ! test -f "$PYTHON_HISTORY_FILE"; then
    touch "$PYTHON_HISTORY_FILE"
  fi

  # export PIP_REQUIRE_VIRTUALENV
  # PIP_REQUIRE_VIRTUALENV="True"
  export VIRTUALENV_DISTRIBUTE
  VIRTUALENV_DISTRIBUTE="True"
}

layout_rubies() {
  local ruby_ver="$1"
  check_string "$ruby_ver" || return 1

  local ruby_dir="$HOME/.rubies/ruby-$ruby_ver"
  check_string "$ruby_ver" && check_path "$ruby_dir" || return 1
  export RUBY_HOME
  RUBY_HOME="$ruby_dir"

  local ruby_dir_bin="$HOME/.rubies/ruby-$ruby_ver/bin"
  check_exec "$ruby_dir_bin/ruby" || return 1
  PATH_add "$ruby_dir_bin"

  local gem_dir="$HOME/.gem/ruby/$ruby_ver"
  check_path "$gem_dir" || return 1
  export GEM_HOME GEM_PATH
  GEM_HOME="$gem_dir"
  GEM_PATH="$gem_dir"

  local gem_dir_bin="$HOME/.rubies/ruby-$ruby_ver/bin"
  PATH_add "$gem_dir_bin"

  path_add MANPATH "$ruby_dir/share/man"
}

### use

use_bundler() {
  local bundler_dir="$1"
  check_string "$bundler_dir" && check_path "$bundler_dir" || return 1
  local bundler_bin_dir="$bundler_dir/bin"
  check_exec "$bundler_bin_dir/bundler" || return 1

  export BUNDLE_BIN
  BUNDLE_BIN="$bundler_bin_dir"
  PATH_add "$bundler_bin_dir"
}

 use_go() {
  local go_dir="$1"
  check_string "$go_dir" || return 1

  local go_path="$go_dir/.go"
  check_path "$go_path" || return 1
  export GOPATH
  GOPATH="$go_path"

  local go_path_bin="$go_dir/.go/bin"
  PATH_add "$go_path_bin"

  local go_bin_dir="/usr/local/opt/go/libexec/bin"
  check_path "$go_bin_dir" && check_exec "$go_bin_dir/go" || return 1
  PATH_add "$go_bin_dir"
}

use_homebrew() {
  local hb_path="$1"
  check_string "$hb_path"; check_path "$hb_path" || return 1
  PATH_add "$hb_path/bin"
  export HOMEBREW_PATH
  HOMEBREW_PATH="$hb_path"

  local hb_sbin="$hb_path/sbin"
  if test -d "$hb_sbin"; then
    PATH_add "$hb_sbin"
  fi
}

use_nodejs() {
  local node_path="$1"
  check_string "$node_path" && check_path "$node_path" || return 1

  export NODE_HOME
  NODE_HOME="$node_path"
  export NODE_PATH
  NODE_PATH="$node_path/lib/node_modules"
}

use_ansible() {
  local ansible_path="$1"
  check_path "$ansible_path" || return 1

  export ANSIBLE_HOME
  ANSIBLE_HOME="$ansible_path"
  # shellcheck source=/dev/null
  source "$ansible_path/hacking/env-setup" > /dev/null
}

use_auto_ruby () {
  local rb_string
  local rb_ver
  local rb_which
  local rbver_file
  rbver_file="$PWD/.ruby-version"

  if test -f "$rbver_file"; then
    # TODO: support more schemes
    rb_ver="$(cat "$rbver_file")"
    log_status "version ${rb_ver} required in {$(user_rel_path "$rbver_file")}"
    layout rubies "$rb_ver"
    rb_which="$(which ruby)"
    rb_string=$(expect_usage "$rb_which -v" "ruby")
    if test -n "$rb_string"; then
      # TODO: .. message accordingly
      log_status "found in rubies {$(user_rel_path "$rb_which")}; using $rb_string"
    else
      log_error "no ruby matching required version!"; return 2
    fi
  else
    rb_which="$(which ruby)"
    if test -n "$rb_which"; then
      rb_string=$(expect_usage "$rb_which -v" "ruby")
      log_status "found in PATH {$(user_rel_path "$rb_which")}; using $rb_string"
    else
      log_error "no ruby in PATH!"
    fi
  fi
}

use_auto_python () {
  local py_string
  local py_ver
  local py_which
  local pyver_file
  pyver_file="$PWD/.python-version"

  if test -n "$VIRTUAL_ENV"; then
    if test "$VIRTUAL_ENV" = "$PWD"; then
      log_status "virtualenv {$(user_rel_path "$VIRTUAL_ENV")} is active"
    else
      log_status "deactivating virtualenv {$(user_rel_path "$VIRTUAL_ENV")}"
      unset VIRTUAL_ENV
    fi
  # TODO: refine test
  elif test -f "$PWD/bin/activate"; then
    local venv_path
    venv_path="$PWD"
    layout virtualenv "$venv_path"
    py_which="$(which python)"
    # TODO: compare with version number in VIRTUAL_ENV
    py_string=$(expect_usage "$py_which -V" "Python")
    log_status "activated virtualenv {$(user_rel_path "$venv_path")}; using $py_string"
  elif test -f "$pyver_file"; then
    # TODO: support more schemes
    py_ver="$(cat "$pyver_file")"
    log_status "version ${py_ver} required in {$(user_rel_path "$pyver_file")}"
    py_which="$(which python)"
    py_string=$(expect_usage "$py_which -V" "$py_ver")
    if test -n "$py_string"; then
      log_status "found in PATH {$(user_rel_path "$py_which")}; using $py_string"
    else
      log_error "no python matching required version!"; return 2
    fi
      else
    py_which="$(which python)"
    if test -n "$py_which"; then
      py_string=$(expect_usage "$py_which -V" "Python")
      log_status "found in PATH {$(user_rel_path "$py_which")}; using $py_string"
    else
      log_error "no python in PATH!"
    fi
  fi
}

use_auto_setup() {
  use_auto_ruby
  use_auto_python
}

### helper

check_string() {
  if test -z "$1"; then
    log_error "argument is expected to be passed."; return 1
  fi
}

check_path() {
  if ! test -d "$1"; then
    log_error "path '$1' is expected to exist."; return 1
  fi
}

check_exec() {
  if ! test -x "$1"; then
    log_error "file '$1' is expected to be executable."; return 1
  fi
}

# figures the current working directory without relying on PWD (which will change when direnv is done)
get_cwd() {
  p="$(expand_path "$1")"
  # http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash#comment14090830_1403489
  local t="${p%${p##*/}}"
  echo "${t%/}"
}

expect_usage() {
  local bin="$1"
  local should="$2"
  local result
  result=$($bin 2>&1)
  case "$result" in
    *"$should"*)
      echo "$result"
      return 0
      ;;
    '')
      log_error "could not find executable in PATH!"
      return 1
      ;;
    *)
      log_error "expected output to match '$should'!"
      return 1
      ;;
  esac
}

log_prefix() {
  local cwd
  cwd=$(user_rel_path "$(expand_path "$1")")
  export DIRENV_LOG_FORMAT
  DIRENV_LOG_FORMAT=" $(tput setaf 7)[$cwd]$(tput sgr0) $(tput setaf 7)$(tput bold)%s$(tput sgr0)"
}
log_prefix "$1"

### end